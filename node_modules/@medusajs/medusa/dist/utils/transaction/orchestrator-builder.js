"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrchestratorBuilder = void 0;
var OrchestratorBuilder = /** @class */ (function () {
    function OrchestratorBuilder(steps) {
        this.load(steps);
    }
    OrchestratorBuilder.prototype.load = function (steps) {
        this.steps = {
            depth: -1,
            parent: null,
            next: steps
                ? JSON.parse(JSON.stringify((steps.action ? steps : steps.next)))
                : undefined,
        };
        this.updateDepths(this.steps, {}, 1, -1);
        return this;
    };
    OrchestratorBuilder.prototype.addAction = function (action, options) {
        if (options === void 0) { options = {}; }
        var step = this.findLastStep();
        var newAction = __assign({ action: action, depth: step.depth + 1, parent: step.action }, options);
        step.next = newAction;
        return this;
    };
    OrchestratorBuilder.prototype.replaceAction = function (existingAction, action, options) {
        if (options === void 0) { options = {}; }
        var step = this.findOrThrowStepByAction(existingAction);
        step.action = action;
        Object.assign(step, options);
        return this;
    };
    OrchestratorBuilder.prototype.insertActionBefore = function (existingAction, action, options) {
        if (options === void 0) { options = {}; }
        var parentStep = this.findParentStepByAction(existingAction);
        if (parentStep) {
            var oldNext = parentStep.next;
            var newDepth = parentStep.depth + 1;
            if (Array.isArray(parentStep.next)) {
                var index = parentStep.next.findIndex(function (step) { return step.action === existingAction; });
                if (index > -1) {
                    parentStep.next[index] = __assign(__assign({ action: action }, options), { next: oldNext[index], depth: newDepth });
                }
            }
            else {
                parentStep.next = __assign(__assign({ action: action }, options), { next: oldNext, depth: newDepth });
            }
            this.updateDepths(oldNext, parentStep);
        }
        return this;
    };
    OrchestratorBuilder.prototype.insertActionAfter = function (existingAction, action, options) {
        if (options === void 0) { options = {}; }
        var step = this.findOrThrowStepByAction(existingAction);
        var oldNext = step.next;
        var newDepth = step.depth + 1;
        step.next = __assign(__assign({ action: action }, options), { next: oldNext, depth: newDepth, parent: step.action });
        this.updateDepths(oldNext, step.next);
        return this;
    };
    OrchestratorBuilder.prototype.appendTo = function (step, newStep) {
        if (typeof step === "string") {
            step = this.findOrThrowStepByAction(step);
        }
        step.next = __assign(__assign({}, newStep), { depth: step.depth + 1, parent: step.action });
        return this;
    };
    OrchestratorBuilder.prototype.appendAction = function (action, to, options) {
        if (options === void 0) { options = {}; }
        var newAction = __assign({ action: action }, options);
        var branch = this.findLastStep(this.findStepByAction(to));
        this.appendTo(branch, newAction);
        return this;
    };
    OrchestratorBuilder.prototype.move = function (actionToMove, targetAction, _a) {
        var _b = _a === void 0 ? {
            runInParallel: false,
            mergeNext: false,
        } : _a, runInParallel = _b.runInParallel, mergeNext = _b.mergeNext;
        var parentActionToMoveStep = this.findParentStepByAction(actionToMove);
        var parentTargetActionStep = this.findParentStepByAction(targetAction);
        var actionToMoveStep = this.findStepByAction(actionToMove, parentTargetActionStep);
        if (!actionToMoveStep) {
            throw new Error("Action \"".concat(actionToMove, "\" could not be found in the following steps of \"").concat(targetAction, "\""));
        }
        if (Array.isArray(parentActionToMoveStep.next)) {
            var index = parentActionToMoveStep.next.findIndex(function (step) { return step.action === actionToMove; });
            if (index > -1) {
                parentActionToMoveStep.next.splice(index, 1);
            }
        }
        else {
            delete parentActionToMoveStep.next;
        }
        if (runInParallel) {
            if (Array.isArray(parentTargetActionStep.next)) {
                parentTargetActionStep.next.push(actionToMoveStep);
            }
            else if (parentTargetActionStep.next) {
                parentTargetActionStep.next = [
                    parentTargetActionStep.next,
                    actionToMoveStep,
                ];
            }
        }
        else {
            if (actionToMoveStep.next) {
                if (mergeNext) {
                    if (Array.isArray(actionToMoveStep.next)) {
                        actionToMoveStep.next.push(parentTargetActionStep.next);
                    }
                    else {
                        actionToMoveStep.next = [
                            actionToMoveStep.next,
                            parentTargetActionStep.next,
                        ];
                    }
                }
                else {
                    this.appendTo(this.findLastStep(actionToMoveStep), parentTargetActionStep.next);
                }
            }
            else {
                actionToMoveStep.next = parentTargetActionStep.next;
            }
            parentTargetActionStep.next = actionToMoveStep;
        }
        this.updateDepths(actionToMoveStep, parentTargetActionStep, 1, parentTargetActionStep.depth);
        return this;
    };
    OrchestratorBuilder.prototype.moveAction = function (actionToMove, targetAction) {
        this.move(actionToMove, targetAction);
        return this;
    };
    OrchestratorBuilder.prototype.moveAndMergeNextAction = function (actionToMove, targetAction) {
        this.move(actionToMove, targetAction, { mergeNext: true });
        return this;
    };
    OrchestratorBuilder.prototype.mergeActions = function (where) {
        var e_1, _a;
        var actions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            actions[_i - 1] = arguments[_i];
        }
        actions.unshift(where);
        if (actions.length < 2) {
            throw new Error("Cannot merge less than two actions");
        }
        try {
            for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                var action = actions_1_1.value;
                if (action !== where) {
                    this.move(action, where, { runInParallel: true });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    OrchestratorBuilder.prototype.deleteAction = function (action, steps) {
        if (steps === void 0) { steps = this.steps; }
        var actionStep = this.findOrThrowStepByAction(action);
        var parentStep = this.findParentStepByAction(action, steps);
        if (Array.isArray(parentStep.next)) {
            var index = parentStep.next.findIndex(function (step) { return step.action === action; });
            if (index > -1 && actionStep.next) {
                if (actionStep.next) {
                    parentStep.next[index] = actionStep.next;
                }
                else {
                    parentStep.next.splice(index, 1);
                }
            }
        }
        else {
            parentStep.next = actionStep.next;
        }
        this.updateDepths(actionStep.next, parentStep, 1, parentStep.depth);
        return this;
    };
    OrchestratorBuilder.prototype.pruneAction = function (action) {
        var actionStep = this.findOrThrowStepByAction(action);
        var parentStep = this.findParentStepByAction(action, this.steps);
        if (Array.isArray(parentStep.next)) {
            var index = parentStep.next.findIndex(function (step) { return step.action === action; });
            if (index > -1) {
                parentStep.next.splice(index, 1);
            }
        }
        else {
            delete parentStep.next;
        }
        return this;
    };
    OrchestratorBuilder.prototype.findStepByAction = function (action, step) {
        var e_2, _a;
        if (step === void 0) { step = this.steps; }
        if (step.action === action) {
            return step;
        }
        if (Array.isArray(step.next)) {
            try {
                for (var _b = __values(step.next), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var subStep = _c.value;
                    var found = this.findStepByAction(action, subStep);
                    if (found) {
                        return found;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        else if (step.next && typeof step.next === "object") {
            return this.findStepByAction(action, step.next);
        }
        return;
    };
    OrchestratorBuilder.prototype.findOrThrowStepByAction = function (action, steps) {
        if (steps === void 0) { steps = this.steps; }
        var step = this.findStepByAction(action, steps);
        if (!step) {
            throw new Error("Action \"".concat(action, "\" could not be found"));
        }
        return step;
    };
    OrchestratorBuilder.prototype.findParentStepByAction = function (action, step) {
        var e_3, _a;
        if (step === void 0) { step = this.steps; }
        if (!step.next) {
            return;
        }
        var nextSteps = Array.isArray(step.next) ? step.next : [step.next];
        try {
            for (var nextSteps_1 = __values(nextSteps), nextSteps_1_1 = nextSteps_1.next(); !nextSteps_1_1.done; nextSteps_1_1 = nextSteps_1.next()) {
                var nextStep = nextSteps_1_1.value;
                if (!nextStep) {
                    continue;
                }
                if (nextStep.action === action) {
                    return step;
                }
                var foundStep = this.findParentStepByAction(action, nextStep);
                if (foundStep) {
                    return foundStep;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (nextSteps_1_1 && !nextSteps_1_1.done && (_a = nextSteps_1.return)) _a.call(nextSteps_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return;
    };
    OrchestratorBuilder.prototype.findLastStep = function (steps) {
        if (steps === void 0) { steps = this.steps; }
        var step = steps;
        while (step.next) {
            step = Array.isArray(step.next)
                ? step.next[step.next.length - 1]
                : step.next;
        }
        return step;
    };
    OrchestratorBuilder.prototype.updateDepths = function (startingStep, parent, incr, beginFrom) {
        if (incr === void 0) { incr = 1; }
        if (!startingStep) {
            return;
        }
        var update = function (step, parent, beginFrom) {
            step.depth = beginFrom + incr;
            step.parent = parent.action;
            if (Array.isArray(step.next)) {
                step.next.forEach(function (nextAction) { return update(nextAction, step, step.depth); });
            }
            else if (step.next) {
                update(step.next, step, step.depth);
            }
        };
        update(startingStep, parent, beginFrom !== null && beginFrom !== void 0 ? beginFrom : startingStep.depth);
    };
    OrchestratorBuilder.prototype.build = function () {
        if (!this.steps.next) {
            return {};
        }
        var ignore = ["depth", "parent"];
        var result = JSON.parse(JSON.stringify(Array.isArray(this.steps.next) ? this.steps : this.steps.next, null), function (key, value) {
            if (ignore.includes(key)) {
                return;
            }
            return value;
        });
        return result;
    };
    return OrchestratorBuilder;
}());
exports.OrchestratorBuilder = OrchestratorBuilder;
//# sourceMappingURL=orchestrator-builder.js.map