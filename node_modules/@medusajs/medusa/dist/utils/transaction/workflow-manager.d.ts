import { MedusaContainer } from "@medusajs/types";
import { DistributedTransaction, TransactionMetadata } from "./distributed-transaction";
import { TransactionOrchestrator } from "./transaction-orchestrator";
import { TransactionStepHandler } from "./transaction-step";
import { TransactionStepsDefinition } from "./types";
import { OrchestratorBuilder } from "./orchestrator-builder";
interface Workflow {
    id: string;
    handler: (container: MedusaContainer) => TransactionStepHandler;
    orchestrator: TransactionOrchestrator;
    flow_: TransactionStepsDefinition;
    handlers_: Map<string, {
        invoke: InvokeHandler;
        compensate?: CompensateHandler;
    }>;
    requiredModules?: Set<string>;
    optionalModules?: Set<string>;
}
declare type InvokeHandler = (container: MedusaContainer, payload: any, invoke: {
    [actions: string]: any;
}, metadata: TransactionMetadata) => Promise<any>;
declare type CompensateHandler = (container: MedusaContainer, payload: any, invoke: {
    [actions: string]: any;
}, compensate: {
    [actions: string]: any;
}, metadata: TransactionMetadata) => Promise<any>;
export declare class WorkflowManager {
    protected static workflows: Map<string, Workflow>;
    protected container: MedusaContainer;
    constructor(container?: MedusaContainer);
    static unregister(workflowId: string): void;
    static unregisterAll(): void;
    static getWorkflows(): Map<string, Workflow>;
    static getTransactionDefinition(workflowId: any): OrchestratorBuilder;
    static register(workflowId: string, flow: TransactionStepsDefinition | OrchestratorBuilder, handlers: Map<string, {
        invoke: InvokeHandler;
        compensate?: CompensateHandler;
    }>, requiredModules?: Set<string>, optionalModules?: Set<string>): void;
    static update(workflowId: string, flow: TransactionStepsDefinition | OrchestratorBuilder, handlers: Map<string, {
        invoke: InvokeHandler;
        compensate?: CompensateHandler;
    }>, requiredModules?: Set<string>, optionalModules?: Set<string>): void;
    private static buildHandlers;
    begin(workflowId: string, uniqueTransactionId: string, input?: unknown): Promise<DistributedTransaction>;
    registerStepSuccess(workflowId: string, idempotencyKey: string, response?: unknown): Promise<DistributedTransaction>;
    registerStepFailure(workflowId: string, idempotencyKey: string, error?: Error | any): Promise<DistributedTransaction>;
}
export {};
