import { JoinerServiceConfig } from "../joiner";
import { Logger } from "../logger";
import { MedusaContainer } from "../common";
import { RepositoryService } from "../dal";
export declare type Constructor<T> = new (...args: any[]) => T;
export * from "../common/medusa-container";
export declare type LogLevel = "query" | "schema" | "error" | "warn" | "info" | "log" | "migration";
export declare type LoggerOptions = boolean | "all" | LogLevel[];
export declare enum MODULE_SCOPE {
    INTERNAL = "internal",
    EXTERNAL = "external"
}
export declare enum MODULE_RESOURCE_TYPE {
    SHARED = "shared",
    ISOLATED = "isolated"
}
export declare type InternalModuleDeclaration = {
    scope: MODULE_SCOPE.INTERNAL;
    resources: MODULE_RESOURCE_TYPE;
    dependencies?: string[];
    resolve?: string;
    options?: Record<string, unknown>;
    alias?: string;
    main?: boolean;
};
export declare type ExternalModuleDeclaration = {
    scope: MODULE_SCOPE.EXTERNAL;
    server?: {
        type: "http";
        url: string;
        keepAlive: boolean;
    };
    alias?: string;
    main?: boolean;
};
export declare type ModuleResolution = {
    resolutionPath: string | false;
    definition: ModuleDefinition;
    options?: Record<string, unknown>;
    dependencies?: string[];
    moduleDeclaration?: InternalModuleDeclaration | ExternalModuleDeclaration;
    moduleExports?: ModuleExports;
};
export declare type ModuleDefinition = {
    key: string;
    registrationName: string;
    defaultPackage: string | false;
    label: string;
    canOverride?: boolean;
    isRequired?: boolean;
    isQueryable?: boolean;
    dependencies?: string[];
    defaultModuleDeclaration: InternalModuleDeclaration | ExternalModuleDeclaration;
};
export declare type LoadedModule = unknown & {
    __joinerConfig: JoinerServiceConfig;
    __definition: ModuleDefinition;
};
export declare type LoaderOptions<TOptions = Record<string, unknown>> = {
    container: MedusaContainer;
    options?: TOptions;
    logger?: Logger;
};
export declare type ModuleLoaderFunction = (options: LoaderOptions, moduleDeclaration?: InternalModuleDeclaration) => Promise<void>;
export declare type ModulesResponse = {
    module: string;
    resolution: string | false;
}[];
export declare type ModuleExports = {
    service: Constructor<any>;
    loaders?: ModuleLoaderFunction[];
    migrations?: any[];
    models?: Constructor<any>[];
    runMigrations?(options: LoaderOptions, moduleDeclaration?: InternalModuleDeclaration): Promise<void>;
    revertMigration?(options: LoaderOptions, moduleDeclaration?: InternalModuleDeclaration): Promise<void>;
};
export interface ModuleServiceInitializeOptions {
    database: {
        clientUrl: string;
        schema?: string;
        driverOptions?: Record<string, unknown>;
        debug?: boolean;
    };
}
export declare type ModuleServiceInitializeCustomDataLayerOptions = {
    manager?: any;
    repositories?: {
        [key: string]: Constructor<RepositoryService>;
    };
};
